/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   actions.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: automated <auto@local>                      +#+  +:+
	+#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/02 19:40:00 by automated         #+#    #+#             */
/*   Updated: 2025/10/05 19:20:00 by automated        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"
#include <stdio.h>
#include <unistd.h>

static int	is_sim_stopped(t_table *table)
{
	int	ret;

	pthread_mutex_lock(&table->sim_stop_lock);
	ret = table->sim_stop;
	pthread_mutex_unlock(&table->sim_stop_lock);
	return (ret);
}

int	write_status(t_philo *philo, const char *status)
{
	t_table	*table;
	long	ts;
	int		id;
	int		stop;

	if (!philo || !status)
		return (0);
	table = philo->table;
	stop = is_sim_stopped(table); // primero leemos esto
	pthread_mutex_lock(&table->write_lock);
	if (!stop)
	{
		ts = get_timestamp(table->start_time);
		id = (int)philo->id;
		printf("%ld %d %s\n", ts, id, status);
	}
	pthread_mutex_unlock(&table->write_lock);
	return (1);
}

void	sleep_philo(long duration_ms, t_table *table, int check_stop)
{
	long	start;

	start = get_time_ms();
	if (check_stop)
		while (!table->sim_stop && get_time_ms() - start < duration_ms)
			usleep(100);
	else
		while (get_time_ms() - start < duration_ms)
			usleep(100);
}

long	calc_think_time(t_philo *philo)
{
	t_table	*table;
	long	time_left;
	long	time_to_think;

	table = philo->table;
	pthread_mutex_lock(&philo->meal_mutex);
	time_left = table->time_to_die - (get_time_ms() - philo->last_meal);
	pthread_mutex_unlock(&philo->meal_mutex);
	time_to_think = (time_left - table->time_to_eat) / 2;
	if (time_to_think < 0)
		time_to_think = 0;
	if (time_to_think > table->time_to_sleep)
		time_to_think = table->time_to_sleep / 2;
	return (time_to_think);
}

int	eat(t_philo *philo)
{
	t_table	*table;
	int		first_fork;
	int		second_fork;

	if (!philo)
		return (0);
	table = philo->table;
	if (philo->fork[0] < philo->fork[1])
	{
		first_fork = philo->fork[0];
		second_fork = philo->fork[1];
	}
	else
	{
		first_fork = philo->fork[1];
		second_fork = philo->fork[0];
	}
	pthread_mutex_lock(&table->forks[first_fork]);
	write_status(philo, STATUS_FORK);
	pthread_mutex_lock(&table->forks[second_fork]);
	write_status(philo, STATUS_FORK);
	pthread_mutex_lock(&philo->meal_mutex);
	philo->last_meal = get_time_ms();
	pthread_mutex_unlock(&philo->meal_mutex);
	write_status(philo, STATUS_EATING);
	sleep_philo(table->time_to_eat, table, 1);
	pthread_mutex_lock(&table->sim_stop_lock);
	if (!table->sim_stop)
		philo->times_ate++;
	pthread_mutex_unlock(&table->sim_stop_lock);
	pthread_mutex_unlock(&table->forks[second_fork]);
	pthread_mutex_unlock(&table->forks[first_fork]);
	return (1);
}

void	*routine(void *arg)
{
	t_philo	*philo;
	long	time_to_think;

	philo = (t_philo *)arg;
	if (!philo)
		return (NULL);
	if (philo->table->n_philos == 1)
	{
		write_status(philo, STATUS_FORK);
		sleep_philo(philo->table->time_to_die, philo->table, 1);
		return (NULL);
	}
	if (philo->id % 2 == 0)
		sleep_philo(philo->table->time_to_eat / 2, philo->table, 0);
	while (!is_sim_stopped(philo->table))
	{
		if (!eat(philo))
			break ;
		if (philo->table->must_eat_count != -1
			&& philo->times_ate >= (unsigned int)philo->table->must_eat_count)
			break ;
		sleep_philo(philo->table->time_to_sleep, philo->table, 1);
		time_to_think = calc_think_time(philo);
		if (time_to_think > 0)
			sleep_philo(time_to_think, philo->table, 1);
		write_status(philo, STATUS_THINKING);
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: auto-generated                              +#+  +:+      
	+#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/01 00:00:00 by copilot           #+#    #+#             */
/*   Updated: 2025/10/01 00:00:00 by copilot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

int	ft_atoi(const char *str)
{
	int	result;
	int	sign;

	result = 0;
	sign = 1;
	while ((*str >= 9 && *str <= 13) || *str == ' ')
		str++;
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			sign = -1;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		result = result * 10 + (*str - '0');
		str++;
	}
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: automated <auto@local>                      +#+  +:+
	+#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/02 21:12:00 by automated         #+#    #+#             */
/*   Updated: 2025/10/02 21:12:00 by automated        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"
#include <stdlib.h>

int	init_philosophers(t_table *table)
{
	int	i;

	if (!table)
		return (0);
	table->philos = malloc(sizeof(t_philo *) * table->n_philos);
	i = 0;
	while (i < table->n_philos)
	{
		table->philos[i] = malloc(sizeof(t_philo));
		if (!table->philos[i])
			return (0);
		table->philos[i]->id = i + 1;
		table->philos[i]->times_ate = 0;
		table->philos[i]->fork[0] = i;
		table->philos[i]->fork[1] = (i + 1) % table->n_philos;
		if (i % 2)
		{
			table->philos[i]->fork[0] = (i + 1) % table->n_philos;
			table->philos[i]->fork[1] = i;
		}
		table->philos[i]->table = table;
		table->philos[i]->last_meal = -1;
		pthread_mutex_init(&table->philos[i]->meal_mutex, NULL);
		i++;
	}
	return (1);
}

int	init_forks(t_table *table)
{
	int	i;

	table->forks = malloc(sizeof(pthread_mutex_t) * table->n_philos);
	if (!table->forks)
		return (0);
	i = 0;
	while (i < table->n_philos)
	{
		pthread_mutex_init(&table->forks[i], NULL);
		i++;
	}
	return (1);
}

int	init_table(t_table *table, int argc, char **argv)
{
	if (!table)
		return (0);
	table->n_philos = ft_atoi(argv[1]);
	table->time_to_die = ft_atoi(argv[2]);
	table->time_to_eat = ft_atoi(argv[3]);
	table->time_to_sleep = ft_atoi(argv[4]);
	if (argc == 6)
		table->must_eat_count = ft_atoi(argv[5]);
	else
		table->must_eat_count = -1;
	if (table->n_philos < 1 || table->time_to_die < 0 || table->time_to_eat < 0
		|| table->time_to_sleep < 0 || (argc == 6 && table->must_eat_count < 0))
		return (0);
	table->sim_stop = 0;
	pthread_mutex_init(&table->write_lock, NULL);
	pthread_mutex_init(&table->sim_stop_lock, NULL);
	if (!init_philosophers(table) || !init_forks(table))
		return (0);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: agarcia <agarcia@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 23:26:31 by agarcia           #+#    #+#             */
/*   Updated: 2025/10/06 01:28:55 by agarcia          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./philo.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int	check_arguments(int argc, char **argv)
{
	int	i;

	i = 1;
	if (argc < 5 || argc > 6)
		return (0);
	while (i < argc)
	{
		if (*argv[i] < '0' || *argv[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

int	create_threads(t_table *table)
{
	int	i;

	i = 0;
	while (i < table->n_philos)
	{
		if (pthread_create(&table->philos[i]->thread, NULL, routine,
				table->philos[i]) != 0)
			return (0);
		i++;
	}
	if (pthread_create(&table->monitor_thread, NULL, monitor, table) != 0)
		return (0);
	return (1);
}

int	start_simulation(t_table *table)
{
	int	i;

	table->start_time = get_time_ms();
	i = 0;
	while (i < table->n_philos)
	{
		pthread_mutex_lock(&table->philos[i]->meal_mutex);
		table->philos[i]->last_meal = table->start_time;
		pthread_mutex_unlock(&table->philos[i]->meal_mutex);
		i++;
	}
	if (!create_threads(table))
		return (0);
	i = 0;
	while (i < table->n_philos)
	{
		pthread_join(table->philos[i]->thread, NULL);
		i++;
	}
	pthread_join(table->monitor_thread, NULL);
	return (1);
}

int	free_table(t_table *table)
{
	int	i;

	if (!table)
		return (0);
	i = 0;
	while (i < table->n_philos)
	{
		pthread_mutex_destroy(&table->forks[i]);
		pthread_mutex_destroy(&table->philos[i]->meal_mutex);
		free(table->philos[i]);
		i++;
	}
	free(table->philos);
	free(table->forks);
	pthread_mutex_destroy(&table->write_lock);
	pthread_mutex_destroy(&table->sim_stop_lock);
	free(table);
	return (1);
}

int	main(int argc, char **argv)
{
	t_table	*table;

	if (!check_arguments(argc, argv))
	{
		printf(USAGE_MSG, argv[0]);
		return (1);
	}
	table = malloc(sizeof(t_table));
	if (!table)
		return (1);
	if (!init_table(table, argc, argv))
		return (free_table(table));
	if (!start_simulation(table))
		return (free_table(table));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   monitor.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: automated <auto@local>                      +#+  +:+
	+#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/02 20:30:00 by automated         #+#    #+#             */
/*   Updated: 2025/10/02 20:30:00 by automated        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"
#include <unistd.h>

static int	check_all_ate(t_table *table)
{
	int	i;
	int	count;

	if (table->must_eat_count <= 0)
		return (0);
	i = 0;
	count = 0;
	while (i < table->n_philos)
	{
		if ((int)table->philos[i]->times_ate >= table->must_eat_count)
			count++;
		i++;
	}
	return (count == table->n_philos);
}

int	check_philo_dead(t_philo *philo, t_table *table)
{
	long	now;
	int		should_die;

	pthread_mutex_lock(&philo->meal_mutex);
	now = get_time_ms();
	should_die = ((now - philo->last_meal) >= table->time_to_die + 2);
	pthread_mutex_unlock(&philo->meal_mutex);
	if (should_die)
	{
		/* marcar sim_stop de forma protegida (solo una vez) */
		pthread_mutex_lock(&table->sim_stop_lock);
		if (!table->sim_stop)
			table->sim_stop = 1;
		pthread_mutex_unlock(&table->sim_stop_lock);
		/* imprimir muerte de forma serializada */
		pthread_mutex_lock(&table->write_lock);
		printf("%ld %d %s\n", get_timestamp(table->start_time), philo->id,
			STATUS_DIED);
		pthread_mutex_unlock(&table->write_lock);
		return (1);
	}
	return (0);
}

void	*monitor(void *arg)
{
	t_table	*table;
	int		i;

	table = (t_table *)arg;
	if (!table)
		return (NULL);
	while (1)
	{
		i = 0;
		while (i < table->n_philos)
		{
			if (check_philo_dead(table->philos[i], table))
				return (NULL);
			i++;
		}
		if (check_all_ate(table))
		{
			pthread_mutex_lock(&table->sim_stop_lock);
			table->sim_stop = 1;
			pthread_mutex_unlock(&table->sim_stop_lock);
			return (NULL);
		}
		usleep(100);
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   time_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: auto-generated                              +#+  +:+
	+#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/01 00:00:00 by copilot           #+#    #+#             */
/*   Updated: 2025/10/01 00:00:00 by copilot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

long	get_time_ms(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return (tv.tv_sec * 1000L + tv.tv_usec / 1000L);
}

long	get_timestamp(long start_time)
{
	return (get_time_ms() - start_time);
}
