/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: agarcia <agarcia@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 23:26:31 by agarcia           #+#    #+#             */
/*   Updated: 2025/08/23 22:49:12 by agarcia          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./philo.h"
#include <stdio.h>
#include <stdlib.h>

int	ft_atoi(const char *str)
{
	int	result;
	int	sign;

	result = 0;
	sign = 1;
	while ((*str >= 9 && *str <= 13) || *str == ' ')
		str++;
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			sign = -1;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		result = result * 10 + (*str - '0');
		str++;
	}
	return (result * sign);
}

void	init_simulation(t_data *data)
{
	int			i;
	pthread_t	monitor_thread;

	i = 0;
	while (i < data->philo_count)
	{
		pthread_create(&data->philos[i].thread_id, NULL, philo_routine,
			&data->philos[i]);
		i++;
	}
	pthread_create(&monitor_thread, NULL, monitoring_routine, data);
	pthread_join(monitor_thread, NULL);
	i = 0;
	while (i < data->philo_count)
	{
		pthread_join(data->philos[i].thread_id, NULL);
		i++;
	}
}

static void	init_table(t_data *data)
{
	int	i;

	data->forks = malloc(sizeof(pthread_mutex_t) * data->philo_count);
	if (!data->forks)
		return ;
	for (i = 0; i < data->philo_count; ++i)
		pthread_mutex_init(&data->forks[i], NULL);
	data->philos = malloc(sizeof(t_philo) * data->philo_count);
	if (!data->philos)
		return ;
	data->someone_died = 0;
	pthread_mutex_init(&data->print_mutex, NULL);
	pthread_mutex_init(&data->state_mutex, NULL);
	for (i = 0; i < data->philo_count; ++i)
	{
		data->philos[i].id = i + 1;
		data->philos[i].meals_eaten = 0;
		data->philos[i].last_meal = data->start_time;
		pthread_mutex_init(&data->philos[i].meal_mutex, NULL);
		data->philos[i].left_fork = i;
		data->philos[i].right_fork = (i + 1) % data->philo_count;
		data->philos[i].data = data;
	}
}

void	store_data(t_data *data, int argc, char **argv)
{
	data->philo_count = ft_atoi(argv[1]);
	data->time_to_die = ft_atoi(argv[2]);
	data->time_to_eat = ft_atoi(argv[3]);
	data->time_to_sleep = ft_atoi(argv[4]);
	data->must_eat = (argc == 6) ? ft_atoi(argv[5]) : -1;
}

void	cleanup(t_data *data)
{
	int	i;

	i = 0;
	while (i < data->philo_count)
	{
		pthread_mutex_destroy(&data->forks[i]);
		i++;
	}
	pthread_mutex_destroy(&data->print_mutex);
	free(data->forks);
	free(data->philos);
	free(data);
}

int	main(int argc, char **argv)
{
	t_data	*data;

	if (argc != 5 && argc != 6)
	{
		printf("Usage:\n");
		printf("%s number_of_philosophers time_to_die time_to_eat time_to_sleep [data->must_eat]\n",
			argv[0]);
		return (1);
	}
	data = malloc(sizeof(t_data));
	store_data(data, argc, argv);
	data->start_time = get_real_time_ms();
	init_table(data);
	init_simulation(data);
	cleanup(data);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   philo.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: agarcia <agarcia@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 23:11:36 by agarcia           #+#    #+#             */
/*   Updated: 2025/08/23 22:51:38 by agarcia          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PHILO_H
# define PHILO_H

# include <pthread.h>
# include <sys/time.h>

typedef struct s_data
{
	long			start_time;
	int				philo_count;
	int				time_to_die;
	int				time_to_eat;
	int				time_to_sleep;
	int				must_eat;

	pthread_mutex_t	*forks;
	struct s_philo	*philos;

	pthread_mutex_t	print_mutex;
	pthread_mutex_t	state_mutex;
	int				someone_died;
}					t_data;

typedef struct s_philo
{
	int				id;
	int				meals_eaten;
	long			last_meal;
	pthread_mutex_t	meal_mutex;
	pthread_t		thread_id;
	int				left_fork;
	int				right_fork;
	t_data			*data;
}					t_philo;

long				get_timestamp(t_data *data);
void				*philo_routine(void *arg);
long				get_real_time_ms(void);
void				*monitoring_routine(void *arg);

#endif // PHILO_H
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   philo_actions.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: agarcia <agarcia@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/09 00:53:55 by agarcia           #+#    #+#             */
/*   Updated: 2025/08/23 23:16:51 by agarcia          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"
#include <stdio.h>
#include <unistd.h>

/* helpers de estado */
static int	sim_dead(t_data *d)
{
	int	dead;

	pthread_mutex_lock(&d->state_mutex);
	dead = d->someone_died;
	pthread_mutex_unlock(&d->state_mutex);
	return (dead);
}

static void	set_dead(t_data *d)
{
	pthread_mutex_lock(&d->state_mutex);
	d->someone_died = 1;
	pthread_mutex_unlock(&d->state_mutex);
}

/* print seguro (no imprime tras muerte) */
static void	print_status(t_philo *philo, const char *msg, long ts)
{
	pthread_mutex_lock(&philo->data->print_mutex);
	if (!sim_dead(philo->data))
		printf("%ld ms %d %s\n", ts, philo->id, msg);
	pthread_mutex_unlock(&philo->data->print_mutex);
}

/* check muerte de UN philo (usa meal_mutex) */
static int	check_dead_one(t_philo *p)
{
	long	now;
	long	last;

	now = get_timestamp(p->data);
	pthread_mutex_lock(&p->meal_mutex);
	last = p->last_meal;
	pthread_mutex_unlock(&p->meal_mutex);
	if (now - last >= p->data->time_to_die)
	{
		pthread_mutex_lock(&p->data->print_mutex);
		if (!sim_dead(p->data))
		{
			set_dead(p->data);
			printf("%ld ms %d died\n", now, p->id);
		}
		pthread_mutex_unlock(&p->data->print_mutex);
		return (1);
	}
	return (0);
}

/* monitor global */
void	*monitoring_routine(void *arg)
{
	t_data	*d;

	d = (t_data *)arg;
	while (!sim_dead(d))
	{
		for (int i = 0; i < d->philo_count; ++i)
			if (check_dead_one(&d->philos[i]))
				return (NULL);
		usleep(500); // 0.5 ms: preciso para tolerancia <10 ms
	}
	return (NULL);
}

/* sleep fragmentado para reaccionar rápido */
static void	smart_sleep(long ms, t_philo *p)
{
	long	start;

	start = get_timestamp(p->data);
	while (!sim_dead(p->data) && (get_timestamp(p->data) - start) < ms)
	{
		if (check_dead_one(p))
			break ;
		usleep(100); // 0.1 ms ticks
	}
}

/* tomar forks. Devuelve 1 si tiene dos, 0 si no */
void	take_forks(t_philo *philo)
{
	if (philo->data->philo_count == 1)
	{
		pthread_mutex_lock(&philo->data->forks[philo->left_fork]);
		print_status(philo, "has taken a fork", get_timestamp(philo->data));
		// espera hasta morir
		smart_sleep(philo->data->time_to_die, philo);
		pthread_mutex_unlock(&philo->data->forks[philo->left_fork]);
		return ;
	}
	// caso normal: varios filósofos
	pthread_mutex_lock(&philo->data->forks[philo->left_fork]);
	print_status(philo, "has taken a fork", get_timestamp(philo->data));
	pthread_mutex_lock(&philo->data->forks[philo->right_fork]);
	print_status(philo, "has taken a fork", get_timestamp(philo->data));
}

static void	put_forks(t_philo *p)
{
	pthread_mutex_unlock(&p->data->forks[p->left_fork]);
	pthread_mutex_unlock(&p->data->forks[p->right_fork]);
}

static void	philo_eat(t_philo *p)
{
	long	now;

	take_forks(p);
	now = get_timestamp(p->data);
	print_status(p, "is eating", now);
	pthread_mutex_lock(&p->meal_mutex);
	p->last_meal = now;
	pthread_mutex_unlock(&p->meal_mutex);
	smart_sleep(p->data->time_to_eat, p);
	pthread_mutex_lock(&p->meal_mutex);
	p->meals_eaten++;
	pthread_mutex_unlock(&p->meal_mutex);
	put_forks(p);
}

static void	philo_sleep(t_philo *p)
{
	print_status(p, "is sleeping", get_timestamp(p->data));
	smart_sleep(p->data->time_to_sleep, p);
}

static void	philo_think(t_philo *p)
{
	long	think;

	think = (p->data->time_to_die - p->data->time_to_eat
			- p->data->time_to_sleep) / 2;
	if (think < 0)
		think = 0;
	print_status(p, "is thinking", get_timestamp(p->data));
	smart_sleep(think, p);
}

/* rutina */
void	*philo_routine(void *arg)
{
	t_philo	*p;

	p = (t_philo *)arg;
	/* pequeñísimo offset para pares */
	if (p->id % 2 == 0)
		usleep(1000);
	while (!sim_dead(p->data) && (p->data->must_eat == -1
			|| p->meals_eaten < p->data->must_eat))
	{
		philo_think(p);
		if (sim_dead(p->data))
			break ;
		philo_eat(p);
		if (sim_dead(p->data))
			break ;
		philo_sleep(p);
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: agarcia <agarcia@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/09 23:12:25 by agarcia           #+#    #+#             */
/*   Updated: 2025/08/10 13:46:20 by agarcia          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./philo.h"

long	get_timestamp(t_data *data)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return (((tv.tv_sec * 1000) + (tv.tv_usec / 1000)) - data->start_time);
}

long	get_real_time_ms(void)
{
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return (tv.tv_sec * 1000 + tv.tv_usec / 1000);
}