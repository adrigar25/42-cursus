

#include "philo.h"
#include <stdio.h>
#include <unistd.h>

int	write_status(t_philo *philo, const char *status)
{
	t_table	*table;
	long	ts;
	int		id;

	if (!philo || !status)
		return (0);
	table = philo->table;
	pthread_mutex_lock(&table->write_lock);
	if (!table->sim_stop)
	{
		ts = get_timestamp(table->start_time);
		id = (int)philo->id;
		printf("%ld %d %s\n", ts, id, status);
	}
	pthread_mutex_unlock(&table->write_lock);
	return (1);
}

void	sleep_philo(long duration_ms, t_table *table)
{
	long	start;

	start = get_time_ms();
	while (!table->sim_stop)
	{
		if (get_time_ms() - start >= duration_ms)
			break ;
		usleep(100);
	}
}

int	eat(t_philo *philo)
{
	t_table	*table;

	if (!philo)
		return (0);
	table = philo->table;
	pthread_mutex_lock(&table->forks[philo->fork[0]]);
	write_status(philo, STATUS_FORK);
	pthread_mutex_lock(&table->forks[philo->fork[1]]);
	write_status(philo, STATUS_FORK);
	pthread_mutex_lock(&philo->meal_time_lock);
	philo->last_meal = get_time_ms();
	pthread_mutex_unlock(&philo->meal_time_lock);
	write_status(philo, STATUS_EATING);
	sleep_philo(table->time_to_eat, table);
	pthread_mutex_lock(&table->sim_stop_lock);
	if (!table->sim_stop)
		philo->times_ate++;
	pthread_mutex_unlock(&table->sim_stop_lock);
	pthread_mutex_unlock(&table->forks[philo->fork[0]]);
	pthread_mutex_unlock(&table->forks[philo->fork[1]]);
	return (1);
}

int	think(t_philo *philo)
{
	if (!philo)
		return (0);
	write_status(philo, STATUS_THINKING);
	return (1);
}

void	*routine(void *arg)
{
	t_philo	*philo;
	time_t	time_to_think;

	philo = (t_philo *)arg;
	if (!philo)
		return (NULL);
	if (philo->table->n_philos == 1)
	{
		write_status(philo, STATUS_FORK);
		sleep_philo(philo->table->time_to_die, philo->table);
		return (NULL);
	}
	time_to_think = (philo->table->time_to_die - (get_time_in_ms()
				- philo->last_meal) - philo->table->time_to_eat) / 2;
	if (time_to_think < 0)
		time_to_think = 0;
	if (time_to_think > 600)
		time_to_think = 200;
	if (philo->id % 2 == 0)
		usleep(100);
	else if (philo->table->n_philos > 50)
		usleep(100 + (philo->id * 10));
	while (!philo->table->sim_stop)
	{
		if (!eat(philo))
			break ;
		if (philo->table->must_eat_count != -1
			&& philo->times_ate >= (unsigned int)philo->table->must_eat_count)
			break ;
		sleep_philo(philo->table->time_to_sleep, philo->table);
		think(philo);
	}
	return (NULL);
}

#include "philo.h"

int	ft_atoi(const char *str)
{
	int	result;
	int	sign;

	result = 0;
	sign = 1;
	while ((*str >= 9 && *str <= 13) || *str == ' ')
		str++;
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			sign = -1;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		result = result * 10 + (*str - '0');
		str++;
	}
	return (result * sign);
}


#include "philo.h"
#include <stdlib.h>

int	init_philosophers(t_table *table)
{
	int	i;

	if (!table)
		return (0);
	table->philos = malloc(sizeof(t_philo *) * table->n_philos);
	i = 0;
	while (i < table->n_philos)
	{
		table->philos[i] = malloc(sizeof(t_philo));
		if (!table->philos[i])
			return (0);
		table->philos[i]->id = i + 1;
		table->philos[i]->times_ate = 0;
		table->philos[i]->fork[0] = i;
		table->philos[i]->fork[1] = (i + 1) % table->n_philos;
		if (i % 2)
		{
			table->philos[i]->fork[0] = (i + 1) % table->n_philos;
			table->philos[i]->fork[1] = i;
		}
		table->philos[i]->table = table;
		table->philos[i]->last_meal = -1;
		pthread_mutex_init(&table->philos[i]->meal_time_lock, NULL);
		i++;
	}
	return (1);
}

int	init_forks(t_table *table)
{
	int	i;

	table->forks = malloc(sizeof(pthread_mutex_t) * table->n_philos);
	if (!table->forks)
		return (0);
	i = 0;
	while (i < table->n_philos)
	{
		pthread_mutex_init(&table->forks[i], NULL);
		i++;
	}
	return (1);
}

int	init_table(t_table *table, int argc, char **argv)
{
	if (!table)
		return (0);
	table->n_philos = ft_atoi(argv[1]);
	table->time_to_die = ft_atoi(argv[2]);
	table->time_to_eat = ft_atoi(argv[3]);
	table->time_to_sleep = ft_atoi(argv[4]);
	if (argc == 6)
		table->must_eat_count = ft_atoi(argv[5]);
	else
		table->must_eat_count = -1;
	if (table->n_philos < 1 || table->time_to_die < 0 || table->time_to_eat < 0
		|| table->time_to_sleep < 0 || (argc == 6 && table->must_eat_count < 0))
		return (0);
	table->sim_stop = 0;
	pthread_mutex_init(&table->write_lock, NULL);
	pthread_mutex_init(&table->sim_stop_lock, NULL);
	if (!init_philosophers(table) || !init_forks(table))
		return (0);
	return (1);
}


#include "./philo.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int	check_arguments(int argc, char **argv)
{
	int	i;

	i = 1;
	if (argc < 5 || argc > 6)
		return (0);
	while (i < argc)
	{
		if (*argv[i] < '0' || *argv[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

int	create_threads(t_table *table)
{
	int	i;

	i = 0;
	while (i < table->n_philos)
	{
		if (pthread_create(&table->philos[i]->thread, NULL, routine,
				table->philos[i]) != 0)
			return (0);
		i++;
	}
	if (pthread_create(&table->monitor_thread, NULL, monitor, table) != 0)
		return (0);
	return (1);
}

int	start_simulation(t_table *table)
{
	int	i;

	table->start_time = get_time_ms();
	i = 0;
	while (i < table->n_philos)
	{
		pthread_mutex_lock(&table->philos[i]->meal_time_lock);
		table->philos[i]->last_meal = table->start_time;
		pthread_mutex_unlock(&table->philos[i]->meal_time_lock);
		i++;
	}
	if (!create_threads(table))
		return (0);
	i = 0;
	while (i < table->n_philos)
	{
		pthread_join(table->philos[i]->thread, NULL);
		i++;
	}
	pthread_join(table->monitor_thread, NULL);
	return (1);
}

int	free_table(t_table *table)
{
	int	i;

	if (!table)
		return (0);
	i = 0;
	while (i < table->n_philos)
	{
		pthread_mutex_destroy(&table->forks[i]);
		pthread_mutex_destroy(&table->philos[i]->meal_time_lock);
		free(table->philos[i]);
		i++;
	}
	free(table->philos);
	free(table->forks);
	pthread_mutex_destroy(&table->write_lock);
	pthread_mutex_destroy(&table->sim_stop_lock);
	free(table);
	return (1);
}

int	main(int argc, char **argv)
{
	t_table	*table;

	if (!check_arguments(argc, argv))
	{
		printf(USAGE_MSG, argv[0]);
		return (1);
	}
	table = malloc(sizeof(t_table));
	if (!table)
		return (1);
	if (!init_table(table, argc, argv))
		return (free_table(table));
	if (!start_simulation(table))
		return (free_table(table));
	return (0);
}


#include "philo.h"
#include <unistd.h>

static int	check_all_ate(t_table *table)
{
	int	i;
	int	count;

	if (table->must_eat_count <= 0)
		return (0);
	i = 0;
	count = 0;
	while (i < table->n_philos)
	{
		if ((int)table->philos[i]->times_ate >= table->must_eat_count)
			count++;
		i++;
	}
	return (count == table->n_philos);
}

int	check_philo_dead(t_philo *philo, t_table *table)
{
	long	now;

	pthread_mutex_lock(&philo->meal_time_lock);
	now = get_time_ms();
	if ((now - philo->last_meal) >= table->time_to_die)
	{
		pthread_mutex_lock(&table->write_lock);
		if (!table->sim_stop)
		{
			printf("%ld %d %s\n", get_timestamp(table->start_time), philo->id,
				STATUS_DIED);
			pthread_mutex_lock(&table->sim_stop_lock);
			table->sim_stop = 1;
			pthread_mutex_unlock(&table->sim_stop_lock);
		}
		pthread_mutex_unlock(&table->write_lock);
		pthread_mutex_unlock(&philo->meal_time_lock);
		return (1);
	}
	pthread_mutex_unlock(&philo->meal_time_lock);
	return (0);
}

void	*monitor(void *arg)
{
	t_table	*table;
	int		i;

	table = (t_table *)arg;
	if (!table)
		return (NULL);
	while (1)
	{
		i = 0;
		while (i < table->n_philos)
		{
			if (check_philo_dead(table->philos[i], table))
				return (NULL);
			i++;
		}
		if (check_all_ate(table))
		{
			pthread_mutex_lock(&table->sim_stop_lock);
			table->sim_stop = 1;
			pthread_mutex_unlock(&table->sim_stop_lock);
			return (NULL);
		}
		usleep(200);
	}
	return (NULL);
}


#include "philo.h"

long	get_time_ms(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return (tv.tv_sec * 1000L + tv.tv_usec / 1000L);
}

long	get_timestamp(long start_time)
{
	return (get_time_ms() - start_time);
}
